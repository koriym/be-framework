# Be Framework ビルドスクリプト

このディレクトリには、Be Frameworkプロジェクト用のユーティリティスクリプトが含まれています。

## スクリプト

### merge.sh

AIチャットボットのコンテキスト用に、プロジェクトのドキュメント、ソースコード、サンプルをまとめた包括的なテキストファイルを作成します。

**使用方法:**
```bash
./study/merge.sh
```

**出力:**
- プロジェクトルートディレクトリに `merged.txt` を作成
- すべてのMarkdownドキュメント、PHPソースファイル、サンプルを含む
- バイナリファイルとvendorディレクトリは除外
- 各ファイルは相対パスで明確に区切られています

**目的:**
このスクリプトは、AIチャットボット（Claude、ChatGPT等）にプロジェクト全体のコンテキストを単一ファイルで提供し、Be Frameworkコードベースをより良く理解し支援できるようにするために設計されています。

**⚠️ 重要なアップロード手順:**

AIに`merged.txt`を提供する際の注意事項：

1. **まず完全なファイルをアップロード** - 追加の質問やプロンプトなしに、`merged.txt`全体を最初に送信してください
2. **確認を待つ** - AIが完全なコンテキストを読み取り理解したことを確認するまで待ってください
3. **その後に質問開始** - AIが理解を確認した後でのみ、下記の推奨質問リストから質問を始めてください

**初回プロンプトの例:**
```
このBe Frameworkの完全なドキュメントを読んで理解してください。
このファイルには、Be FrameworkとOntological Programmingパラダイムに
関する質問に答えるために必要な全コンテキストが含まれています。

読了後、理解が完了し、Be Frameworkの概念について深く議論する
準備ができたことを確認してください。
```

## 新しいパラダイムを理解するための知的冒険

この`merged.txt`を通じてAIに質問し対話することは、**Be Frameworkパラダイムの全容を理解する新しい試み**です。

### ⚠️ 重要：これは概念実証（POC）フェーズです

Be Frameworkは現在**概念実証フェーズ**にあります。これは以下を意味します：

- **パラダイム探求に重点**を置き、プロダクション対応は二次的
- **概念的理解**が実装上の懸念よりも優先される
- **本番利用、パフォーマンス、チーム導入**に関する質問は現段階では時期尚早の可能性
- 主目的は**Ontological Programmingの哲学的基盤の探求と検証**

即座の実用的応用のための評価ではなく、新しいプログラミングの可能性への知的探求としてアプローチしてください。

### 重要な前提：知的態度の必要性

**新しいパラダイムの発見には特別な知的態度が必要です：**

#### 🍵 まず、カップを空にしてください（Empty Your Cup）
ある教授が禅師のもとを訪れ、教えを求めました。禅師は茶を注ぎ始めましたが、カップが満杯になっても注ぎ続けました。「あふれています！」と教授が叫ぶと、禅師は答えました：「あなたもこのカップと同じです—すでに自分の意見や思い込みで満たされている。それを空にするまで、新しいものは入りません。」

#### 🧭 知的好奇心による探求
- **知的好奇心があれば**：革新的な発見と深い理解への道が開かれます
- **知的好奇心なしでは**：表面的な批判に留まり、何も発見できないかもしれません

#### 📖 判断前の理解
新しいパラダイムを評価する前に、必ず [**レビューアーガイド**](../docs/reviewer-guide/human-ja.md) をお読みください。これは革新的なアイデアに開放的にアプローチしながら批判的思考を維持する方法を説明しています。

#### 🤖 AIの限界の認識
AIは強力なツールですが、新しいパラダイムについて間違った解釈や批判をすることがあります。特に革新的な概念については、AIの回答を批判的に検討し、必要に応じて複数の視点から確認してください。

#### 💡 推奨：大きなコンテキスト容量を持つAIモデル
Be Frameworkの全容を理解するために、**Gemini 2.5 Pro**のような大きなコンテキスト容量を持つAIモデルの使用を強く推奨します。これにより、哲学的基盤から技術的実装まで、全体の一貫性を保ちながら理解を深めることができます。

---

## 完全なドキュメント読了後のAI向け推奨質問

上記の知的態度を持って`merged.txt`を通じてAIに完全なコンテキストを提供した後、Be FrameworkとOntological Programmingパラダイムの深さと含意を探る思慮深い質問をご紹介します：

### 完全初心者向け

Be Frameworkが初めてで、哲学的概念に圧倒されている方はここから始めてください：

- 「Be Frameworkとは何ですか？他のPHPフレームワークとは何が違うのでしょうか？」
- 「なぜプログラミングフレームワークに哲学的な概念が必要なのですか？」
- 「LaravelやSymfonyと比べて、具体的にどのような違いがあるのでしょうか？」
- 「これは実用的なフレームワークなのでしょうか？それとも学術的な理論なのでしょうか？」
- 「仏教哲学などの知識がないとこのフレームワークは使えないのでしょうか？」
- 「『変容』や『存在』といった概念を、もう少しわかりやすく説明していただけませんか？」
- 「学習を始めるにはどうすればよいでしょうか？哲学的な背景を学ばずに使える入門資料はありますか？」
- 「このフレームワークを学ぶことで、プログラマーとしてのスキルは向上するでしょうか？」
- 「コードはより複雑になるのでしょうか？それともシンプルになるのでしょうか？」
- 「同じ機能を従来のPHPとBe Frameworkで実装した場合の比較例を見せていただけますか？」
- 「具体的なメリットは何でしょうか？『時間的プログラミング』を理解する必要性は？」
- 「既存のLaravelやSymfonyプロジェクトに組み込むことは可能でしょうか？全面的な書き直しが必要ですか？」
- 「データベースのORMについてはいかがでしょうか？EloquentやDoctrineは利用できますか？」
- 「習得にはどの程度の時間が必要でしょうか？学習コストはどの程度ですか？」
- 「まず

### 技術的理解

基本概念を理解したら、技術的実装をより深く掘り下げましょう：

- 「生のHTTPリクエストから最終レスポンスまで、Be Frameworkを使った完全な例を見せて。」
- 「#[Be]属性って内部的にどう動くの？私のクラスに何をするの？」
- 「Log-Driven Development（LDD）って何で、従来のログとどう違うの？」
- 「用語集を作って：Being、Becoming、Metamorphosis、Beenなど。」
- 「Be Frameworkの依存性注入は従来のDIコンテナと比べてどう違うの？」
- 「#[Input]、#[Be]、#[Accept]属性の違いは何？」
- 「オブジェクト変容のライフサイクルをステップごとに教えて。」
- 「テストはどうやるの？まだPHPUnitのテストを書くの？」

### 基礎的理解

- 「『何が起こるべきか？』と『何が存在できるか？』のプログラミングにおける根本的違いは？」
- 「変容パターン（`卵 → 幼虫 → 蛹 → 蝶`）は実世界のデータ変換にどう適用されるの？」
- 「Wu Wei（無為）の原理と、Be Frameworkの『無為にして成る』アプローチをわかりやすく説明して。」

### 哲学的深度

- 「Ontological Programmingは従来の命令型プログラミングで説明されている『行動の危機』をどう解決するの？」
- 「『生まれる前に死ぬことはできない』って時間的プログラミングの文脈で何を意味するの？」
- 「Log-Driven Developmentでストレンジループはどう現れて、計算的意識について何を明らかにするの？」

### 実践的実装

- 「ユーザー登録システムでの型駆動変容の具体例を一通り説明して。」
- 「専門家への委譲が必要な複雑なビジネスシナリオで#[Accept]パターンをどう実装する？」
- 「変容アーキテクチャで構築されたシステムのテスト戦略は？」

### パラダイム比較

- 「Be Frameworkの状態管理アプローチは従来のMVCやイベント駆動アーキテクチャとどう違う？」
- 「MetamorphoseパラダイムとDCI（Data-Context-Interaction）を比較して－主要な哲学的違いは？」
- 「Be FrameworkはUNIXのパイプライン哲学を現代のオブジェクト指向システムにどう拡張する？」

### 高度な概念

- 「SchemaLoggerがオブジェクトに自分自身の変容可能性を発見させる仕組みを説明して。」
- 「『究極の透明性』って何で、セマンティックログはどうやって実行可能な仕様になるの？」
- 「ALPSとBe Framework間の双方向生成は実際どう動くの？」

### AI-ネイティブ設計とコラボレーション

Be FrameworkはAIフレンドリーなだけでなく、AI-人間協働のために一から設計されています：

- 「セマンティックログはどうやってシステム全体をAI分析に透明にするの？」
- 「なぜAIは従来のフレームワークよりBe Frameworkのコードを理解しやすいの？」
- 「Log-Driven Development（LDD）はどうやってAIとコードの間にフィードバックループを作るの？」
- 「自己証明オブジェクトはどうやってAIがシステム状態を『推測』する必要をなくすの？」
- 「#[Accept]パターンはどうやって型安全性を保ちながら複雑な決定をAIに委譲するの？」
- 「Beenオブジェクトはどうやって自分の『作業証明』を携帯してAIが直接解釈できるようにするの？」
- 「なぜ『ドキュメントとしてのアーキテクチャ』はAIのコード理解にとって革命的なの？」
- 「オブジェクトの時間的構造はどうやってAIデバッグをより精密にするの？」
- 「AIはドメインモデルを理解するだけで有効なBe Frameworkコードを生成できる？」
- 「双方向ALPS生成はどうやってAI支援API設計を可能にするの？」

### 実装上の考慮事項

- 「フレームワークは複雑で非同期的、または時間のかかる変容をどう扱う？」
- 「変容パターンのパフォーマンス影響は？」
- 「多くのドメイン固有型を扱う時の複雑さをどう管理する？」
- 「既存のPHPエコシステムやライブラリとの統合課題は？」

### 未来のビジョン

- 「Be FrameworkはAI-人間協働の時代にソフトウェア開発をどう準備する？」
- 「『ドキュメントとしてのアーキテクチャ』は大規模システムの保守にどんな役割を果たす？」
- 「BeingパラダイムはPHP以外のプログラミング言語にどう影響するかも？」

これらの質問は、AIの理解をテストしつつ、ソフトウェアアーキテクチャ、計算哲学、開発実践の未来に対するこの新しいプログラミングパラダイムの深遠な含意を明らかにするよう設計されています。

## 大きなファイルの処理

`merged.txt`がAIアシスタントが一度にアップロードするには大きすぎる場合、小さなチャンクに分割できます：

### ファイルを管理可能な部分に分割

```bash
# 4000行ずつのファイルに分割し、.txt拡張子を追加
split -d -l 4000 merged.txt merged_ && for i in merged_*; do mv "$i" "$i.txt"; done

# これで作成されます： merged_00.txt, merged_01.txt, merged_02.txt, など
```

### 分割ファイルのアップロード手順

1. 最初の部分（`merged_00.txt`）をこの指示と共にアップロード：
   ```
   これはBe Frameworkドキュメントの第1部です。この部分を読んで理解してください。まだ返答しないでください。追加部分を送ります。
   ```

2. 続く部分（`merged_01.txt`、`merged_02.txt`など）をこれと共にアップロード：
   ```
   これはBe Frameworkドキュメントの第2/3/4...部です。この部分を読んで理解してください。まだ返答しないでください。続きがあります。
   ```

3. 最後の部分をアップロード後にこう聞いてください：
   ```
   これがBe Frameworkドキュメントの最終部分でした。完全なコンテキストを得たので、理解を確認し、Be FrameworkとOntological Programmingパラダイムについての質問を受ける準備ができたことを教えてください。
   ```

### 分割ファイルのクリーンアップ

```bash
# 使用後に分割ファイルを削除
rm merged_[0-9][0-9].txt
```

このアプローチにより、ファイルサイズ制限内で作業しながら、AIが完全なコンテキストを受け取ることが保証されます。
