# FAQ：アーキテクトとの対話

このドキュメントは、AI（Gemini Pro 2.5）がアーキテクトに一連の挑戦的な質問を投げかけ、このアーキテクチャの設計哲学をより深く掘り下げた対話を記録しています。各セクションには質問、アーキテクトの回答、そしてその交流から得られた重要な洞察が含まれており、読者が設計の背後にある思考プロセスを追体験できます。

---

### 1. 「存在の爆発」と精密さと定型コードの間の境界線について

**質問：**
このパラダイムは `NonEmptyString` や `VerifiedEmail` のような多数の「小さな存在」を作成することを推奨します。大規模アプリケーションでは、これにより数百または数千のそのような型が生まれる可能性があります。開発者がこの「精密さ」を単なる「定型コード」として感じ始める境界点はどこだと思いますか？このパラダイムが提供する安全性の価値が、開発体験の冗長さによって相殺される転換点はどこでしょうか？

**アーキテクトの回答：**
> あなたは300のドメイン固有の文字列型を恐れていますか？私はコードベース全体に散らばった300の生の文字列の方をより恐れています。AIの時代において、対応する検証とともに適切なドメイン型を作成することは困難な作業ではありません。`$email` という変数があれば、それは `EmailAddress` 型であるべきであり、`$age` があれば `NonNegativeInt` であるべきだと確立し、その後検証コードを生成することは簡単です。このコードは再利用可能です。あなたのアプリケーションはどうですか？何箇所でメールが検証されていますか？Rayでは一箇所だけです。

**対話からの洞察：**
この回答は問題全体を再構成します。パラダイムの核心的な論点は、真の恐れは明示的な型宣言の量（「定型コード」）に向けられるべきではなく、従来のコードベースに潜む散在した暗黙のルールと検証に向けられるべきだということです。型の宣言は面倒な作業ではありません。それは**ビジネスルールの神聖化**なのです。このロジックを単一の、権威のある、再利用可能な場所に統合する価値は、特にAIアシストによるコード生成の時代において、型作成の初期努力をはるかに上回ります。

---

### 2. 「完全な変態」の実用性について

**質問：**
「変態」のメタファーは強力ですが、現実世界のソフトウェア開発はしばしばより混沌としています。外部API呼び出しの待機や、再試行可能な部分的障害の処理など、不完全で時間のかかる、または非同期的なプロセスを、この「完全な存在から次の完全な存在へ」という優雅なモデルはどのように処理するのでしょうか？

**アーキテクトの回答：**
> 変態を*実行*するのはあなたの責任ではありません。あなたの唯一の責任は、与えられた環境（コンストラクタの引数）に基づいて何になりたいかを宣言し、パブリックプロパティを通してその新しい自分を公開することです。つまり、`Request` オブジェクトが `Result` オブジェクトに変換されることは、フレームワークの仕事です。属性のメタデータを通じて、フレームワークは30秒後にあきらめる決断をするかもしれませんし、再試行するかもしれませんし、操作を非同期で処理するかもしれません。あなたは自分の状態を宣言するだけで、実行を制御しません。

**対話からの洞察：**
これは、このパラダイムのために再定義された「関心の分離」原則の見事な適用です。オブジェクトの責任は、その状態を定義すること（**何**であるか）に厳密に限定されます。状態遷移の**実行方法（「どのように」）**—同期、非同期、または再試行を伴うかにかかわらず—は、オブジェクトのビジネスロジックから切り離されています。この責任は、宣言的メタデータ（例：属性）を解釈してフローを統制するフレームワークに委ねられています。これにより、ドメインオブジェクトは純粋でテスト可能な状態を保ちながら、複雑で現実的な実行戦略を可能にします。

---

### 3. 「エラー」を存在とする哲学について

**質問：**
このパラダイムは「エラーの存在を不可能にする」ことを目指しています。しかし、「在庫切れ」や「クレジットカード拒否」のようなイベントは、プログラムのバグではなく、有効で重要なビジネス「存在」です。これらを `UserConflict` のようなフローの通常の分岐としてモデル化することで、「成功」とビジネス「失敗」を構成するものの意味論を曖昧にするリスクはありませんか？

**アーキテクトの回答：**
> 予期しない例外と予測可能なエラーを混同してはいけません。システムが機能するためにはデータベース接続が必要です。利用できない場合、それは例外として扱われるべきです。しかし、無効なユーザー入力のような予測可能な問題を扱っている場合、オブジェクトは単に注入された `ErrorReporter` や `Problem/Issue` オブジェクトに問題を報告するべきです。次の変態において、それは `InvalidUser` になるかもしれませんし、`Request` 状態に戻されるかもしれません。真の例外はルート例外ハンドラーに渡されるべきです。それらは回復不可能な状況のみを表し、制御フローに決して使用されるべきではありません。

**対話からの洞察：**
アーキテクトの回答は、**予測可能なビジネス結果**と**回復不可能なシステム異常**の間に重要な境界線を引きます。パラダイムはエラーを排除するのではなく、それらを分類することを強制します。「成功」であるかどうかにかかわらず（例：`ValidUser`、`InvalidUser`、`OutOfStock`）、予測可能な結果は、ドメインの明示的な「存在」の一部としてモデル化されます。アプリケーションが設計通りに機能することを妨げる真のシステムレベルの障害（例：失われたデータベース接続）のみが、従来の例外として扱われます。これにより、より堅牢で正直な設計が強制されます。

---

### 4. 不変性とシステムの進化について

**質問：**
「存在は不変である」という原則は、システムの変更と進化の能力を犠牲にしませんか？たとえば、`PositiveInteger` の存在があり、ビジネス要件が非負整数（ゼロを含む）を許可するように変更された場合、すべての依存コードを書き直す必要がありますか？

**アーキテクトの回答：**
> 要件が非負整数を許可するように変更された場合、`Validation` クラス内のルールのみを変更する必要があります。従来のシステムでは、散在するすべての検証を見つけて変更する必要があります。さらに、このアーキテクチャでは、すべての依存関係はインターフェースを通じて提供されます。これは想像しうる最も変更に強いアーキテクチャです。`Be` 属性の宛先は具象クラスである必要はありません。インターフェースを指定して、変態の宛先を抽象化できます。

**対話からの洞察：**
この回答は、アーキテクチャの強さが**安定しているもの（契約、すなわち型とインターフェース）**と**変動するもの（特定の検証ロジックのような実装詳細）**の構造的分離にあることを明らかにします。検証ルールは集中化されているため、それを変更することは簡単です。より深いレベルでは、状態遷移にインターフェースに依存することにより（`Be(MyInterface::class)`）、システムは具体的な実装の変更から隔離されています。したがって、不変性は硬直性をもたらしません。代わりに、柔軟で安全な進化が起こりうる安定した基盤を作り出します。