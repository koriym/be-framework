# Being Paradigm Terminology

A concise glossary of key terms in the Being Paradigm, listed alphabetically for quick reference.

## A

### Augmented Decision Making (AMD)
An approach combining deterministic rules, AI pattern recognition, and human intuition to handle complex decisions. Preserves rich context and embraces uncertainty through Undetermined states.

## B

### #[Be] Attribute
A declaration of what an object is destined to become. Enables Type-Driven Metamorphosis by mapping object types to their next transformation stage.  
*Example: `#[Be([Success::class, Failure::class])]`

### Being Class
The foundational concept in Ontological Programming representing objects that exist in time, carry their nature, and undergo self-determined transformation. Embodies temporal existence and subject-object unity.

### being life
Objects that exist, change, and have meaning. The ultimate expression of the Being Paradigm where code becomes alive through the integration of Being + Change + Meaning.

### Being Property
A special property (typically `$being`) using union types to express an object's potential futures or destiny. Enables internal self-determination.  
*Example: `public readonly Success|Failure $being;`

## C

### Constructor Workshop Theory
The principle that constructors are complete workshops of transformation where all logic resides, tools are used once, and the transformed self emerges immutable.

## E

### Existence as Proof
The principle that if something exists, it is correct by definition. Encompasses both Construction is Proof and Semantic Variables are Proof.

### Existence Contract
A declaration of what must exist for an entity to exist, what it is when it exists, and what its existence enables.

### Existential Question
The internal process by which objects discover their own nature through self-assessment, typically expressed as "Who am I?" in the being property.

## F

### Fork-Join Pattern
A parallel assembly pattern where a single context initiates multiple parallel transformations that later converge into a composite object.

## I

### #[Input] Attribute
Marks constructor parameters that inherit data from the previous metamorphosis stage.

### #[Inject] Attribute
Marks constructor parameters that receive transient capabilities from the dependency injection container.

## L

### Linear Metamorphic Chain
A sequential transformation pattern where each stage leads deterministically to the next: A → B → C → D.

## M

### Metamorphic Programming
The implementation layer of the Being Paradigm focusing on object transformation through stages of existence.

## N

### Nature
The inherent essence of a Being that guides its transformation without external control.

## O

### Ontological Programming
A programming paradigm where objects focus on "being" rather than "doing," modeling software after existential concepts with immutability and self-determination.

## P

### Public Readonly Properties
The principle that all object properties are public and immutable, ensuring transparency and preventing state mutation.

## S

### SchemaLogger
A logging mechanism capturing complete execution stories as structured logs, enabling AI analysis to discover potential object evolutions.

### Semantic Variable Names
Variable names that carry meaning and validation contracts, where the existence of a properly named variable serves as proof of its validity.

### Subject-Object Unity
The philosophical principle that in the Being Paradigm, all objects are their own subjects—there is no external controller commanding objects.

## T

### Temporal Being
The aspect of Being Classes that exist in time with memory of past and knowledge of potential futures.

### Type-Driven Metamorphosis
The mechanism where objects use union types and the being property to self-determine their next form, eliminating explicit control flow.

## U

### Unchanged Name Principle
The principle that property names remain consistent across metamorphic stages to preserve identity and continuity through transformation.

### Undetermined State
A state representing an object's honest acknowledgment of its limitations, triggering delegation to appropriate expertise through the #[Accept] pattern.

### Union Type Destiny
The use of union types to express all possible futures an object might inhabit, serving as destiny maps rather than classifications.

## W

### "Whether?"
The fundamental question of Ontological Programming—asking what can exist rather than how things should be done. Contrasts with "How?" (Imperative), "Who?" (OOP), and "What?" (Functional).
